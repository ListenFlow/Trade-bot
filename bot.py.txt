Listen Flow, [07.02.2025 14:03]
import ccxt
import time
import numpy as np
import pandas as pd
import os
from datetime import datetime

# Настройки API
api_key = os.getenv('BYBIT_API_KEY')  # ключ Bybit
api_secret = os.getenv('BYBIT_API_SECRET')  # секретный ключ

# Инициализация Bybit
exchange = ccxt.bybit({
    'apiKey': api_key,
    'secret': api_secret,
    'options': {'defaultType': 'future'}
})

# Настройки
symbol = 'PEPEUSDT'  # Трейдовая пара
leverage = 50  # Плечо
trade_amount = 1  # Сумма для торговли
take_profit_percentage = 0.5  # Тейк-профит в %
stop_loss_percentage = 0.5  # Стоп-лосс в %

# Получаем баланс
def get_balance():
    balance = exchange.fetch_balance()
    return balance['total']['USDT']

# Получаем свечи для анализа
def get_ohlcv(symbol, timeframe='1m'):
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    return df

# Открытие позиции
def open_position(symbol, side, amount):
    print(f"Открытие {side} позиции на {symbol}...")
    order = exchange.create_market_order(symbol, side, amount)
    return order

# Закрытие позиции
def close_position(symbol):
    print(f"Закрытие позиции на {symbol}...")
    position = exchange.fetch_positions(symbol)
    if position:
        for pos in position:
            if pos['side'] == 'long':
                exchange.create_market_order(symbol, 'sell', abs(pos['contracts']))
            elif pos['side'] == 'short':
                exchange.create_market_order(symbol, 'buy', abs(pos['contracts']))
                
# Торговая логика
def trade():
    balance = get_balance()
    print(f"Баланс: {balance} USDT")
    
    # Установка плеча
    exchange.futures_set_leverage(symbol, leverage)
    
    # Получаем данные для анализа
    df = get_ohlcv(symbol)
    
    # Расчет сигналов для торговли на основе свечных паттернов + объема
    # Используем простую стратегию на основе 2 последних свечей и их объема
    if len(df) < 2:
        return  # Недостаточно данных для торговли
    
    # Последняя свеча
    last_candle = df.iloc[-1]
    prev_candle = df.iloc[-2]
    
    if last_candle['close'] > last_candle['open'] and prev_candle['close'] < prev_candle['open']:  # Быковая свеча
        side = 'buy'
    elif last_candle['close'] < last_candle['open'] and prev_candle['close'] > prev_candle['open']:  # Медвежья свеча
        side = 'sell'
    else:
        return  # Нет сигнала
    
    # Открытие позиции
    open_position(symbol, side, trade_amount)

    # Ожидаем прибыли или стоп-лосса
    while True:
        # Проверяем текущую цену
        current_price = exchange.fetch_ticker(symbol)['last']
        
        # Рассчитываем целевые цены для тейк-профита и стоп-лосса
        take_profit_price = current_price * (1 + take_profit_percentage / 100) if side == 'buy' else current_price * (1 - take_profit_percentage / 100)
        stop_loss_price = current_price * (1 - stop_loss_percentage / 100) if side == 'buy' else current_price * (1 + stop_loss_percentage / 100)
        
        # Проверка на тейк-профит или стоп-лосс
        if side == 'buy':
            if current_price >= take_profit_price:
                close_position(symbol)
                print(f"Тейк-профит достигнут на {symbol}, прибыль: {take_profit_percentage}%")
                break
            elif current_price <= stop_loss_price:
                close_position(symbol)
                print(f"Стоп-лосс сработал на {symbol}, убыток: {stop_loss_percentage}%")
                break
        elif side == 'sell':
            if current_price <= take_profit_price:
                close_position(symbol)
                print(f"Тейк-профит достигнут на {symbol}, прибыль: {take_profit_percentage}%")
                break
            elif current_price >= stop_loss_price:
                close_position(symbol)
                print(f"Стоп-лосс сработал на {symbol}, убыток: {stop_loss_percentage}%")
                break
        
        # Пауза между проверками
        time.sleep(5)

Listen Flow, [07.02.2025 14:03]
# Основной цикл
while True:
    trade()
    time.sleep(10)